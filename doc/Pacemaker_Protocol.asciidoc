Pacemaker Protocol - the heart of real-time machine control
===========================================================
:toc:
:numbered:
:showcomments:

The most up to date version of this file can be found at
https://github.com/JustAnother1/Pacemaker

This document defines the protocol used to communicate between the Pacemaker host and Pacemaker Client. The Pacemaker Protocol concept and initial design was created by Lars PÃ¶tter and Robert Fairlie-Cuninghame.

== Summary

The Pacemaker protocol provides an open interface to allow the separation of real-time and non-real-time control components for 3D printers, CNC machines and laser cutters.

This has the huge benefit of allowing new controller hardware (the real-time component) to work with existing host software solutions (the non-real-time component) and similarly, for new host software solutions to easily work with existing controller hardware.

Pacemaker allows a much deeper level of real-time machine control from non-real-time application software. This ability provides the opportunity to develop feature-rich host software, more integrated start-to-finish tool chain solutions whilst still being able to operate on a wide range of platforms.

== Environment

The Pacemaker system can be used in situations where a application controls the operation of a machine. Examples for such a situation are 3d printing, CNC milling or laser cutters. The usual machine control setup is something like this:

---------------------------------------------------------------------

    Application -> G-Code -> Firmware <-> Hardware.

---------------------------------------------------------------------

The application creates the instructions of what the machine should do as commands encoded in the G-Code format. This G-Code data is then sent to the machine where the Firmware of the machine receives the data, decodes the G-Codes and executes the command by directly controlling the hardware.

=== The need for robust real time control

Some hardware components need to be accurately controlled every fraction of a millisecond. If the control signals stop or are send too late the machine could be damaged or the quality of the work that the machine does is decreased. It is therefore necessary to have a CPU close to the hardware and to not control the hardware directly from the Application as the hardware needs to be controlled in real time. Even for small CPUs real-time command execution is possible, as these CPUs run no operation system or a special real-time operating system. As these systems are specially designed to do just this and there are no influences that could cause the control signals to be delayed.

But this hard real time functionality of the machine's firmware comes with a cost. These processors may have very limited computational performance and are usually far more time-consuming to use as a development platform. The firmware has to be developed with the timing requirements in mind. This makes the firmware development more complicated than normal application development and and even so optimal motion control algorithms may require more computational power than is available. The more functions that need to be executed in the machine controller raises the effort to create the firmware, and if the machine's controller CPU has to become more powerful this usually increases the system cost.

It is therefore desirable to have only the functionality that needs the real-time accuracy in the machine's firmware and let the host application control the machine using a standard interface. Traditionally G-Codes have often been used to achieve this.

With the growing requirements on the speeds of movement, support for non-linear/Cartesian movement systems, co-ordinate remapping for auto-bed levelling features, increased precision of movement, thus it is becoming apparent a better separation is required between motion planning and real-time motion control.

=== The separation of higher functions from real time control

The Pacemaker system is the next step to reduce the complexity of the machine's firmware by moving the complicated calculations out of the machines firmware. The Pacemaker system therefore changes the usual setup. The setup with a Pacemaker system may look like this:

-------------------------------------------------------------------------------

    Application -> G-Code -> Pacemaker-Host <-> Pacemaker-Client <-> Hardware.

-------------------------------------------------------------------------------

The integration of the Pacemaker system can be a simple extension of the usual machine setup. The only component of the usual setup that needs to be changed is the machines firmware. And the change of the machines firmware, to reduce its complexity and performance demands on the machines limited CPU was the intention.

The Pacemaker host and Pacemaker client replace the firmware and implement all functionality that has been previously been fulfilled by the firmware. This way the Application does not need to be changed if the environment is changed from a usual setup to a Pacemaker system.

The functionality needed to control the hardware according to the G-Code commands is split between host and client so that the host executes the complicated calculations and the client executes the real time control signal generation.

In this split the client focuses on the hardware control and hardware supervision. The client only executes pre-processed orders from the host and reports back the results of the hardware supervision.

It is the host's responsibility to decode the G-Code commands and to translate them into commands that are easily executable by the client. It is also the host's responsibility to process the hardware supervision signals from the client and to react accordingly.

It is the intention to support not only one specific machine, but a broad spectrum of machines. To be able to do that the differences of the machines need to be handled. The differences between the machines fall into one of these categories:

- different feature set
- different hardware components

The pacemaker system is flexible enough to deal with these differences.

An advanced application can also take direct control of a Pacemaker Client by implementing its own Pacemaker host and motion planning layer (also possibly bypassing the G-code control layer), however, it is encouraged that writing reusable, open-source extensions/plugins to the common Pacemaker Host implementation is at least investigated beforehand.

=== Pacemaker - a hardware abstraction for real-time control

The Pacemaker protocol allows the host to request the available hardware capabilities to mitigate the differences in the supported feature set. As the same host software can be used for different machines the same features are available for all supported machines that have the needed hardware capabilities for the feature. The host application can then adapt the behavior to the machine's ability. This allows it to always use the best features possible with the machine.

The differences in the hardware of the machines has to be mitigated by the client. It is therefore not possible to have one Pacemaker client board that is best suitable for all supported machines.  A single Pacemaker client firmware implementation may be used in many different physical printer configurations. To avoid separate client firmware implementations for each different physical machine configuration, two mechanisms will be used:

- The first is that the Pacemaker client will only report the abstract hardware functionality that is available. The host then needs a mapping of these abstract hardware features to their specific use in the machine. An example for such a mapping would be that the first stepper controls the X axis and that the second stepper controls the Y axis. A Pacemaker client board can also have support for more hardware capabilities than the machine has. The client could support three temperature sensors whereas the machine has only 2 sensors.
- The second mechanism is that the client board deals with the differences in how the hardware features are implemented and therefore does not expose these differences to the host. Examples for this would be different kind of temperature sensors. If the client board has the needed hardware components to support different types of temperature sensor the use can connect the sensors available in the machine. By using the correct connector, configuring a jumper, or by configuration of the firmware the Pacemaker client board would be able to read the correct temperature values from the different sensors and would report only the measured temperature to the host.

The host therefore could work with all these machines as it doesn't know and doesn't care which sensor type was used. This is also a benefit if the user wants to upgrade the machine. Because the only thing that needs to be done is to integrate a better sensor into the machine and to configure the Pacemaker client board to work with the new sensor. The host does not need to be changed at all.

The protocol is designed with a transport layer that is independent from the transported data. It is therefore possible to use the Pacemaker protocol with different communication channels. Currently UART and I^2^C communication is supported.

The transport layer is specifically adopted to the used communication channel. Different communication channels therefore have different transport layers but the same command layer.

As the firmware on the Pacemaker client should be as simple as possible not all client boards need to implement all the features. The protocol allows the host to request the list of supported features from the client. This makes configurations where the Pacemaker client only controls a part of the machines hardware easier. For such configurations the host software needs to be extended to be able to control the other function through some other mechanism.

All commands shall be answered as fast as possible by the client. For commands that take a long time (several milliseconds) to execute the reply shall not wait for the end of the execution. If a result of the lengthy process needs to be reported back to the host then this has to be done with a separate communication.

Hardware capabilities that are available more than once on the client will be numbered starting with zero. The request of the number of these capabilities will be answered with the amount and not with the number of the last instance. Generally speaking the last available instance of a hardware capability will be the number of available instances minus one.

So if a client reports that the hardware supports 3 Heaters they will be identified using device index 0, 1 & 2. The host however can ask the client for a "friendly" name for each heater which in most cases would match the labelling of the board, e.g., "EXTR1", "EXTR2" & "HBED". This allows a user to more easily associate an advertised device (e.g., heater index 0) with the correct high-level function (e.g., the heater for extruder 1); or conversely, to ensure that the wiring for a particular function is connected to the correct pins using the labels printed on the board.

== Terms & Definitions

=== Movement Directions
One end of each axis is the minimum end. The other end is the maximum end. Moving from the minimum to the maximum end is a move in *increasing* direction. Moving from the maximum end to the minimum end is a movement in *decreasing* direction.

=== Number Format
All numbers in this document that are not specially marked are decimal numbers (10 = 9 + 1).
All numbers that are prefixed with 0x are hexadecimal numbers (0x10 = 16; 9 + 1 = 0x0A).
All numbers that are prefixed with 0b are binary numbers (0b10 = 2).

=== Byte Order - Bit Order
If data types longer than 8 bit are used then they are send with the Most Significant Byte(MSB) first and the Least Significant Byte(LSB) last. Within a Byte the bit numbered 0 is the Least Significant Bit(LSB and the bit 7 is the Most Significant Bit(MSB). As an Example the Number 9026 that equals the hex string 0x2342 would be transferred as 0x23 followed by 0x42.

=== Error Check Code (CRC-8)
The CRC used is defined by this polynomial C(_x_) = _x_^8^ + _x_^6^ + _x_^3^ + _x_^2^ + 1 = 0b101001101. A calculator is available at http://ghsi.de/CRC/index.php?Polynom=101001101

An Example implementation in C is this:
[source,c,numbered]
---------------------------------------------------------------------
static const uint8_t crc_array[256] =
{
    0x00U, 0xa6U, 0xeaU, 0x4cU, 0x72U, 0xd4U, 0x98U, 0x3eU,
    0xe4U, 0x42U, 0x0eU, 0xa8U, 0x96U, 0x30U, 0x7cU, 0xdaU,
    0x6eU, 0xc8U, 0x84U, 0x22U, 0x1cU, 0xbaU, 0xf6U, 0x50U,
    0x8aU, 0x2cU, 0x60U, 0xc6U, 0xf8U, 0x5eU, 0x12U, 0xb4U,
    0xdcU, 0x7aU, 0x36U, 0x90U, 0xaeU, 0x08U, 0x44U, 0xe2U,
    0x38U, 0x9eU, 0xd2U, 0x74U, 0x4aU, 0xecU, 0xa0U, 0x06U,
    0xb2U, 0x14U, 0x58U, 0xfeU, 0xc0U, 0x66U, 0x2aU, 0x8cU,
    0x56U, 0xf0U, 0xbcU, 0x1aU, 0x24U, 0x82U, 0xceU, 0x68U,
    0x1eU, 0xb8U, 0xf4U, 0x52U, 0x6cU, 0xcaU, 0x86U, 0x20U,
    0xfaU, 0x5cU, 0x10U, 0xb6U, 0x88U, 0x2eU, 0x62U, 0xc4U,
    0x70U, 0xd6U, 0x9aU, 0x3cU, 0x02U, 0xa4U, 0xe8U, 0x4eU,
    0x94U, 0x32U, 0x7eU, 0xd8U, 0xe6U, 0x40U, 0x0cU, 0xaaU,
    0xc2U, 0x64U, 0x28U, 0x8eU, 0xb0U, 0x16U, 0x5aU, 0xfcU,
    0x26U, 0x80U, 0xccU, 0x6aU, 0x54U, 0xf2U, 0xbeU, 0x18U,
    0xacU, 0x0aU, 0x46U, 0xe0U, 0xdeU, 0x78U, 0x34U, 0x92U,
    0x48U, 0xeeU, 0xa2U, 0x04U, 0x3aU, 0x9cU, 0xd0U, 0x76U,
    0x3cU, 0x9aU, 0xd6U, 0x70U, 0x4eU, 0xe8U, 0xa4U, 0x02U,
    0xd8U, 0x7eU, 0x32U, 0x94U, 0xaaU, 0x0cU, 0x40U, 0xe6U,
    0x52U, 0xf4U, 0xb8U, 0x1eU, 0x20U, 0x86U, 0xcaU, 0x6cU,
    0xb6U, 0x10U, 0x5cU, 0xfaU, 0xc4U, 0x62U, 0x2eU, 0x88U,
    0xe0U, 0x46U, 0x0aU, 0xacU, 0x92U, 0x34U, 0x78U, 0xdeU,
    0x04U, 0xa2U, 0xeeU, 0x48U, 0x76U, 0xd0U, 0x9cU, 0x3aU,
    0x8eU, 0x28U, 0x64U, 0xc2U, 0xfcU, 0x5aU, 0x16U, 0xb0U,
    0x6aU, 0xccU, 0x80U, 0x26U, 0x18U, 0xbeU, 0xf2U, 0x54U,
    0x22U, 0x84U, 0xc8U, 0x6eU, 0x50U, 0xf6U, 0xbaU, 0x1cU,
    0xc6U, 0x60U, 0x2cU, 0x8aU, 0xb4U, 0x12U, 0x5eU, 0xf8U,
    0x4cU, 0xeaU, 0xa6U, 0x00U, 0x3eU, 0x98U, 0xd4U, 0x72U,
    0xa8U, 0x0eU, 0x42U, 0xe4U, 0xdaU, 0x7cU, 0x30U, 0x96U,
    0xfeU, 0x58U, 0x14U, 0xb2U, 0x8cU, 0x2aU, 0x66U, 0xc0U,
    0x1aU, 0xbcU, 0xf0U, 0x56U, 0x68U, 0xceU, 0x82U, 0x24U,
    0x90U, 0x36U, 0x7aU, 0xdcU, 0xe2U, 0x44U, 0x08U, 0xaeU,
    0x74U, 0xd2U, 0x9eU, 0x38U, 0x06U, 0xa0U, 0xecU, 0x4aU
};

uint8_t crc8(uint8_t *data, unsigned int length)
{
    uint8_t crc = 0;
    while (length-- > 0)
    {
        crc = crc_array[*data ^ crc];
        data = data + 1;
    }
    return crc;
}
---------------------------------------------------------------------

== Transport Layer
The transport layer consists of the host sending out Order frames that the client responds to with a Reply frame. The transport layer is communication channel dependent; however, the Pacemaker protocol is intended to work over a variety of channels - including bi-directional serial channels and with master-slave communications channels like I^2^C.

=== Host-Client Communication
All critical communication between the host and the client is started by the host. Only the host may send out Order frames. The client must answer each Order frame with a Reply frame. The timeout for the client to respond is 100ms (by default). This includes the time it takes to send and receive the data and is measured on the host. The client therefore has less than 100ms from the time of reception of the order to the sending of the reply.

==== Unsolicited Client Frames
In transport mechanisms which support client initiated data transmission, then the client may send out unacknowledged packets for certain purposes. The two current uses for these unsolicited client frames are for sending debug messages (primarily to support development) and to quickly notify the host that a new event is available for collection. The host does not respond to these unsolicited frames.

An unsolicited client frame has the same structure as a normal Reply frame but has bit 7 set in the Control Byte. The client should increment the sequence number in the Control Byte with each unsolicited frame it sends. These sequence numbers however have no correlation to the sequence numbers sent & received in normal Order and Reply frames.

For transport mediums which do not support client initiated communications then the host should either poll for the presence of new events or use a separate interrupt line to indicate a change in state.

=== Communication Over a Standard Serial Channel(UART, RS232)

==== Serial Communication Parameters
All communication parameters like data rate, parity, start/stop bits have to be known before the communication can start. They cannot be changed or read out using this protocol. The host shall support as much possible configuration as possible. The client must support at least one configuration. The client must provide the information about which configuration it supports in its documentation. This information must be made available to the host by the user.

==== Order Frame Format

Order frames are only sent by the host.

[width="50%",options="header", cols="30%,70%"]
|=============================
|Length in bytes| Field
| 1             | Sync
| 1             | Length (=N+2)
| 1             | Control
| 1             | Order code
| N             | Parameter
| 1             | Error Check Code (CRC-8)
|=============================

The *Sync* field has the value 0x23 and signals the start of the frame.

The *Length* field contains the number of bytes consumed by the Control, Order code and Parameter field. The length of the parameter field is length - 2. The length of 0 and 1 is not valid.

The *Control* byte is currently used to convey a 4-bit rolling sequence number to detect duplicate transmissions. The sequence number is sent in bits 3-0 (low order nibble). Bit 4 indicates that the host has reset or lost synchronization and is restarting communication (which has the effect of clearing any cached responses). Bits 7-5 (high order nibble) are reserved for future use and must be set to 0 by the host.

The *Order code* field is explained in the Order section.

The *Parameter* field is optional and the data depends on the Order. The possible contents of this field are described in the Order section.

The *Error Check Code* field contains a CRC-8 value calculated over the Order code, Control, Length, & Parameter field values. The Error Check Code must be used by the client to verify that the frame has been correctly received.

==== Reply Frame Format

Replies will only be sent by the Pacemaker client in response to an Order frame from the host.

[width="50%",options="header", cols="30%,70%"]
|=============================
|Length in bytes| Field
| 1             | Sync
| 1             | Length (=N+2)
| 1             | Control
| 1             | Reply code
| N             | Parameter
| 1             | Error Check Code (CRC-8)
|=============================

The *Sync* field has the value 0x42 and signals the start of the frame.

The *Length* field contains the number of bytes consumed by the Control, Reply code and Parameter field. The length of the parameter field is length - 2. The length of 0 and 1 is not valid.

The *Control* byte is currently used to convey a 4-bit rolling sequence number to detect duplicate or out-of-sync transmissions. The sequence number is sent in bits 3-0 (low order nibble) and the value must match that of the Order to which it is replying. Bit 4 is used by the Event Reporting Extension to indicate that event data is available for collection. Bit 7 is used to indicate that the response contains a debug message - these packets can either be ignored without action by the host or routed to a debug console. Bits 6-5 are reserved for future use and must be set to 0.

The *Reply code* field is explained in the Reply section.

The *Parameter* field is optional and the data depends on the reply. The possible contents of this field are described in the Reply section.

The *Error Check Code* field contains a CRC-8 value calculated over the Reply code, Control, Length & Parameter field values. The Error Check Code must be used by the host to verify that the frame has been correctly received.

=== Communication over a I^2^C Serial Bus channel

This section describes how to send the Pacemaker protocol using I^2^C.

==== I^2^C Frame Format

The host initially performs a write of the Order frame:

.Order Frame Format for I^2^C
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length in bytes| Field
| 1             | Address in bit 7 to 1 and R/W in bit 0 = 0
| 1             | Length (=N+2)
| 1             | Control
| 1             | Order Code
| N             | Parameter
| 1             | Error Check Code (CRC8)
|=============================

and then immediately performs a read of the Reply frame:

.Reply Frame Format for I^2^C
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length in bytes| Field
| 1             | Address in bit 7 to 1 and R/W in bit0 = 1
| 1             | Length (=N+2)
| 1             | Control
| 1             | Reply Code
| N             | Parameter
| 1             | Error Check Code (CRC8)
|=============================

By default the client should use I^2^C bus *Address* 0x31 (0110-001x) but the host and client must support the ability to change this value if necessary.

The *Length*, *Order Code*, *Reply Code*, *Control* and *Parameter* fields are as described for the standard serial communication frame format.

The *Error Check Code* field contains a CRC-8 value calculated over all preceding byte values. This also includes the address.

A repeated Start bit pattern is permitted between writing the Order and reading the Reply.

NOTE: It is expected that the client will need to use I^2^C clock stretching to implement the Pacemaker protocol (this is where the client holds the clock line low until it has completed preparing the response). Not all I^2^C implementations support clock-stretching correctly or at all. Of particular note for Raspberry Pi users, there is bug in the Rev A and Rev B Raspberry Pi silicon which means that clock stretching support is not reliable. On these platforms the "i2c-gpio" module can be used instead to robustly implement this feature.

== Command Layer

=== Common Definitions

==== Protocol Versions
The current pre-release version of the Pacemaker protocol is 0.1. All current and previous versions of the protocol are listed in the table below along with a summary of the important changes between each version. New Protocol version will be defined in an updated version of this document. Major protocol version numbers indicate breaking changes; minor protocol version numbers indicate non-breaking changes.

.Protocol Versions
[width="50%",options="header", cols="20%,20%,60%"]
|================================================
|Major Ver|Minor Ver| Changes
|   0     |    1    | Initial pre-release protocol version.
|================================================

(Note however that backwards compatibility with pre-release protocol versions (0.x) will not be maintained once version 1.0 is released.)

A Pacemaker client is only expected to implement a single protocol version. A Pacemaker host may (or may not) support a range of different client protocol versions.

The Pacemaker host should ignore extra Reply Parameter bytes when the client version mismatches only by a minor version.
The Pacemaker client should ignore extra Order Parameter bytes (the Host should not try to use a client with a mismatched major version).
Both the Pacemaker client and host should return an error if insufficient Parameter bytes are received (additional Parameter content should be marked as optional when extending a command with a minor version change).

==== Protocol Extensions
Protocol extensions are created so that clients only implement the set of functionality that they require (or are capable of implementing).

The following extensions are currently defined:

.Protocol Extensions
[width="50%",options="header", cols="30%,70%"]
|================================================
|Value| Extension
|   0 | Stepper Control
|   1 | Queued Command
|   2 | Basic Move
|   3 | Event Reporting
| 0x80-0xfe | Experimental/unapproved protocol extensions
|================================================

New extensions can be introduced to the protocol without changing the protocol version.

==== Device Type
Some Orders can be applied to more than one device type. A common definition of device types is used to differentiate device numbers for commands that accept multiple device types.

.Device Type
[width="50%",options="header", cols="30%,70%"]
|================================================
|Value| Device Type
| 0x0 | Reserved (to indicate invalid device type)
| 0x1 | Switch inputs
| 0x2 | Switch outputs
| 0x3 | PWM controlled outputs
| 0x4 | Stepper
| 0x5 | Heater
| 0x6 | Temperature Sensor
| 0x7 | Buzzer
| 0x80-0xfe | Experimental/unapproved device types
|================================================

===== Device Type Descriptions

The following section described the different device types and which orders can be used on these device types. Note however that the "Request Device Count", "Request Device Name" and "Request Device Status" orders can be used with all device types.

Aside: When firmware specific configuration is mentioned for a device type, this is referring to use of the generic "Write Firmware Configuration Value" order and is not referring to the provision of firmware specific Pacemaker orders, responses or Parameter values (the latter is discouraged because it makes the host implementation also firmware specific).

The *Switch inputs* are digital input devices which are either in a "triggered" or "not triggered" state. The switch state is read using the "Request State of Switch" order. The interpretation of "triggered"/"not triggered" states depends on the device connected. For instance, the host understands what a triggered endstop switch means, regardless of whether the electrical switch is normally-open, normally-closed, active-high or active-low. Configuration between the input signal level and the triggered state is provided by client configuration including whether input pull-up needs to be provided or not.

The *Switch outputs* are tri-state output devices. The "Switch an Output" order is used to change the output device state. In addition to Low and High logic levels, a switch output device also supports a tri-state/high-impedance output state. The high impedance state is the default initial state of these devices but this may be modified by client firmware configuration (and determined by reading the device status).

The *PWM controlled outputs* are digital outputs which support hardware or software controlled pulse-width modulation. The duty cycle of the PWM output is controlled by the "Set PWM Output Value" order. The frequency of the PWM is implementation specific and may even be controllable through firmware specific configuration (for instance, if software controlled PWM is enabled on a pin, then this typically operates at a much low lower frequency).

The *Stepper* devices are stepper motors controlled by the client. The actual control mechanism can be through a variety of technologies, for instance, dedicated Enable/Step/Direction to a stepper control module or SPI serial bus controlled motors. The Stepper devices are primarily controlled by the commands in Stepper Control and Basic Move protocol extensions.

A *Heater* device consists of the following components: the heater drive output(s), the heater control algorithm and a temperature sensor. The Heater device output is controlled through the "Set Heater Target Temperature" order. The current temperature of the heater can be read using the "Request Temperature Reading" order (or alternatively by reading the temperature of the associated temperature sensor device). The drive and control algorithm for a heater are all controlled through firmware specific configuration. The temperature sensor associated with a heater can be configured either through the Pacemaker "Configure Heater" order or through firmware specific configuration (the most appropriate option may depend on whether there is a firm association between particular temperature sensor inputs and heater output pins through labelling on the controller board).

A *Temperature Sensor* device is an analogue input (only) device. The current temperature of the sensor is read using the "Request Temperature Reading" order. The thermistor or thermocouple type is configured through firmware specific configuration.

A *Buzzer* device is a device which is capable of playing an audio tone of a specified frequency. The output frequency is set using the "Set Output Tone" order.

A *Power off output" is a special case of digital output device. When the "Switch an Output" order is used to set the High output state of this device type (and there will only be one instance of this device type), then the client will turn itself off. Turning the client on again usually requires manual intervention. Power controls for auxiliary power supplies or auxiliary systems can usually be implemented using standard Switch Outputs as opposed to the client "Power off output". [The Power off output often requires special initialization as the device powers up, hence, the dedicated device type.]

Other device types are planned for the future such as rotary encoders, GPIOs and displays.

==== Experimental & Unapproved Functionality Identifiers

For each major protocol identifier a range has been allocated for implementers to use with experimental or proposed extensions to the Pacemaker protocol. A separate range is allocated to ensure that collisions do not occur between approved extensions and experimental features. Any extensions not described in this document must use the allocated Experimental/Unapproved identifier range until adopted as a supported extension. The experimental range has been defined for protocol identifiers such as protocol extension ids, device types, order codes, reply codes, command block ids, event type ids.

Typically the top half of the range is reserved for experimental & unapproved identifiers, e.g., 0x80-0xfe for 1 byte identifiers.

=== Sending and Receiving Frames

.Host Frame Transmission Rules

If the host application has just reset or lost communication with the host, then the first Order it sends should set Bit4 in the Control byte to ensure that the client doesn't reply with a cached response.

After the host side sends an Order frame to the client, it should wait for a complete Reply frame to be received. Here are the Serial Reply Frame reception rules for the host:

1. If the host has not received the start of a frame, then it ignores all bytes which are not a Sync byte.
2. If the host has received a Sync byte but has not received sufficient bytes for the frame and at least 20ms have elapsed since the last byte was received, then the bytes are discarded and the order is retransmitted.
3. If the host has received sufficient frame bytes but the sequence number or Error Check Code is invalid, then the order is retransmitted.
4. If a transport layer error is received, then the order is retransmitted.
5. If 100ms elapses without a valid application layer response, then the order is retransmitted.

Otherwise, when the host receives a valid frame with matching sequence number and a reply code greater than 0x0f, then retransmission stops and the reply is passed to the application layer. Valid unsolicited client frames received during this period do not affect the retransmission of orders or reception of replies.

Note that the host should limit itself to sending no more than 2 order retransmissions for reasons other than the 100ms timeout. This limitation is to prevent the client getting stuck in a tight error retransmission loop with the host (for instance, because it is repeatedly trying to frame start sync on a Sync byte value in the data payload). Retransmissions due to the 100ms timeout can however continue to occur until the host decides to give up.

Retransmission with I^2^C is simpler as the client will simply hold the clock low until it is able to return a response or generate an error. Framing is also inherent in the I^2^C bus protocol. However, retransmission due to malformed frames, invalid sequence numbers, bad error check codes, time outs and transport layer errors remains unchanged.

.Client Order Frame Reception

When waiting for a complete frame, the client should behave as follows:

1. If the client has not received the start of a frame, then it ignores all bytes which are not a Sync byte.
2. If the client has received a Sync byte but has not received sufficient bytes for the frame and at least 20ms have elapsed since the last byte was received, then a Bad Frame reply is sent (if the Control byte was received) and the bytes discarded.
3. If the client has received sufficient frame bytes but the Error Check Code is invalid, then a Bad Error Check Code reply is sent and the bytes discarded.

If a frame is received with a valid Error Check Code then:

- if the sequence number matches the previously accepted sequence number and bit 4 in the Control byte was not set, then the Client must re-transmit the saved reply frame and discard the received Order frame, otherwise,
- the client can discard the previously cached response once a new valid order frame has been received,
- if the client is currently in an unacknowledged stopped state and the order is not a Resume, then a Stopped reply is generated, otherwise
- the client executes the Order and must send a reply. The client must also save a copy of the Reply frame that it sends.

=== Client Power-On State

When the client comes out of reset, by default it will have the following states:

- the Stopped state is asserted (with Reset cause).
- all motors stopped
- all heaters off
- all outputs either in an inactive or high-impedance state

Firmware configuration may however require that some outputs have a default active state or that internal pullups are enabled in the "disabled" state. This may be necessary for instance when a device has an active low enable state and external pullups have not been provided on the controller. The exact state of each output initially or after a stopped condition can be determined using the "Request Device Status" order.

=== Standard Transport Layer Reply Codes

These Reply code indicate that a transport-layer error occurred, in other words, the frame was not received correctly or it was rejected at the transport layer.

The numeric value used for each Reply code is indicated in the parentheses after the code title. All transport layer reply codes use a reply code value of 0x00 to 0x0f.

==== Frame Receipt Error (0x00)

This is a generic transport layer error indication either that the frame was corrupted or rejected. All Frame Receipt Errors simply include a reason code and optional reason string.

The following table applies for the first byte:
[width="50%",options="header", cols="30%,70%"]
|=============================
|Parameter| Meaning
| 0x0 | Bad frame
| 0x1 | Bad Error Check Code
| 0x2 | Unable to accept frame
|=============================

Following the first byte of the Parameter, an optional UTF8 string is expected giving the human readable reason for the error.

The *Bad Frame* Reply Code is sent according to the client receive rules described later.

The *Bad Error Check Code* Reply Code is sent only when the correct number of bytes were received but the Error Check Code is incorrect.

The *Unable to accept frame* Reply Code is sent when the host cannot process the frame due to a transient reason.

It is expected that retransmission of an Order which received a Frame Receipt Error Reply may result in a successful delivery.

==== Experimental/Unapproved Reply Codes

The Reply Code range 0x08-0x0f is reserved for experimental or unapproved transport Reply Code values.

=== Standard Application Layer Reply Codes

The following section describes standard Reply codes used by the application layer of the protocol. Extensions are however allowed to define additional Reply codes.

The Application Layer Reply codes indicate that the frame was received correctly by the client (but may still have been rejected or failed for other reasons).

==== OK (0x10)
This response signals that the Order has been executed successfully.
The Parameter content is Order-specific and described for each Order.

==== Generic Application Error (0x11)
The generic application errors indicate that there was a command or application level condition which prevented the Order from the being accepted.

The first byte of the Parameter indicates the cause of the error. The following generic application errors are defined:
[width="50%",options="header", cols="30%,70%"]
|=============================
|Parameter| Meaning
| 0x1 | Unknown Order
| 0x2 | Bad Parameter Format
| 0x3 | Bad Parameter Value
| 0x4 | Invalid Device Type Specified
| 0x5 | Invalid Device Number Specified
| 0x6 | Incorrect mode (e.g., not SPI Master)
| 0x7 | Busy (e.g., if command can't be executed while Orders queued)
| 0x8 | Failed
| 0x9 | Firmware Error
| 0xa | Device Unavailable
|=============================

Following the first byte of the Parameter, an optional UTF8 string is expected giving the human readable reason for the error.

The *Unknown Order* reply code is sent in response to any unrecognized Order code value.

The *Bad Parameter Format* reply code is sent in response to any Order received where the Parameter value is missing, incomplete or malformed.

The *Bad Parameter Value* reply code is sent in response to any Order received where the Parameter value has the correct format but specifies an illegal or invalid value.

The *Invalid Device Type Specified* reply code is specific sub-case of the more generic "Bad Parameter Value". This code indicates that the Parameter value specified an invalid device type for this order.

The *Invalid Device Number Specified* reply code is specific sub-case of the more generic "Bad Parameter Value". This code indicates that the Parameter value specified an invalid device number for this order.

The *Incorrect mode* reply code is sent in response to any Order received where the Order code is recognized but the mode or configuration of the client prevents the Order from being accepted. For example, receiving stepper control Orders when the client is not the SPI Master is one example for this case

The *Busy* reply code is sent in response to any Order received when the current run-time state prevents the Order being accepted. For instance, Orders which can only be executed when the Command Queue is empty.

The *Failed* reply code is a generic code which can be used to indicate that the Parameter format and content were valid but the operation failed.

The *Firmware error* reply code indicates that a client firmware error prevented the correct handling of the message (for instance, the command handler returned without generating a response).

The *Device Unavailable* reply code indicates that a configuration, device or client state error prevents the device being used. The Get Device Status order (see order description) can be used to obtain more categorized information on the cause.

If additional Parameter information must be returned (beyond a possible error reason string), then an Order Specific Error can be used.

==== Stopped (0x12)
This Reply code indicates that the order was rejected because the machine is currently in a "stopped" state, due to a movement error (e.g.. end stop hit), electrical error (e.g., out-of-range temperature sensor or stepper motor error), firmware error (e.g., out of heap space) or has just reset.

When in the Stopped state:

- All outputs are returned to their inactive state unless firmware configuration dictates otherwise.
- The Stopped reply code will be returned for all Orders until the Stopped state is acknowledged (or cleared), that is, until a Resume order has been recieved.
- The Stopped reply code will also be returned for all Resume Orders until the Stopped state is successfully cleared (see Resume Order description).
- After the stopped state has been acknowledged, the client will returned the "Device Unavailable" reply code for any Order which attempts to activate motor or heater devices until the Stopped state has been clear. The client may also return this error code for any other devices which the client knows might pose a safety concern in the Stopped state (determined for instance through firmware configuration).
- Otherwise, after the stopped state has been acknowledged, other requests (including requests to change general switch, buzzer or PWM output device states) should be permitted.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length| Meaning
| 1 | Recovery Options
| 1 | Cause
| n | Reason [Optional]
|=============================

The first byte of the Parameter indicates the options for recovery of the fault. The second byte of the Parameter indicates the broad cause for being in the stopped state. Following the second byte of the Parameter, an optional UTF8 string is expected giving the human readable reason for the error.

.Recovery Options
[width="50%",options="header", cols="30%,70%"]
|=============================
|Parameter| Meaning
| 0x1 | One time event or condition cleared.
| 0x2 | Condition persists.
| 0x3 | Unrecoverable.
|=============================

The *One time event or condition cleared* state code indicates that the condition that triggered this state was either a one-time event or has cleared and a Resume Order should be successful.

The *Condition persists* state code indicates the condition that triggered this state still persists. A Resume Order will not clear this condition while the condition remains.

The *Unrecoverable* state code indicates a fatal, unrecoverable error. A Reset Order is required to recover this state.

.Stopped Cause
[width="50%",options="header", cols="30%,70%"]
|=============================
|Parameter| Meaning
| 0x0 | Reset
| 0x1 | End-stop hit
| 0x2 | Movement error (e.g., stepper motor fault)
| 0x3 | Heater/temperature error (e.g., heater temp sensor open circuit)
| 0x4 | Device fault (e.g., fault in some other critical connected device)
| 0x5 | Electrical fault (e.g., supply voltage out of range)
| 0x6 | Firmware fault (e.g., out of memory, fatal error)
| 0x7 | User requested (e.g., emergency stop button hit)
| 0x8 | Host Timeout
| 0x9 | Other fault
|=============================

The *Reset* state code is a specific case indication for the Stopped condition due to a Reset Order or the initial power on condition. A Resume Order should be successful (i.e., the Recovery Option value should be equal to "One time event or condition cleared.").

The *End-stop hit* state code is a specific case indication for the Stopped condition due to an end-stop hit event being triggered. A Resume Order should be successful - even if the end-stop is still triggered (i.e., the Recovery Options value should be equal to "One time event or condition cleared.").

==== Order-specific Errors (0x13)
This Reply code indicates that the Order was unsuccessful for an Order-specific reason. The Order defines the contents of the Parameter field.

=== Unsolicited Client Frames

Unsolicited client frames are primarily indicated by bit 7 being set in the Reply Control Byte; however, by convention they also use a separate range of Reply Codes. The allocated range for approved unsolicited reply codes is 0x50-7f.

It should be remembered that unsolicited frames are not acknowledged so delivery is best effort. Information which requires a degree of reliability should be sent using the Event mechanism.

==== Debug Message (0x50)

This unsolicited client frame simply contains an utf8 string with debug-related information. The primarily intention of this frame is to better support development by providing a non-delayed output message mechanism from the client.
Any Parameter data following a 0x00 value in the message should be treated as binary data and displayed using a hexidecimal representation. The 0x00 value is not considered part of the data.

Text output which is intended for a normal user should be sent using the reliable delivery mechanism provided by the Event extension.

=== Experimental/Unapproved Reply Codes

The Reply Code range 0x80-0xfe is reserved for experimental or unapproved application layer Reply Code values.

== Basic Functionality

This section describes the Orders which all clients are expected to implement. Orders will only be sent by the Pacemaker Host. The Order code used in the communication is given after the order's name in the title.

=== Orders

Each Order description also lists the expected Replies. It is assumed that generic error responses will also be generated and are not always listed, for instance,

- a malformed Parameter value will reply with a Bad Parameter Format code
- requesting an invalid device type or number will reply with Invalid Device Type/Number Specified.

==== Reset (0x7F)

This order will reset the Pacemaker client. See initial client state.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| n/a | This command has no Parameter
|=============================

.Replies
OK: No parameter information defined.

NOTE: The client is allowed to fail to reply to this. The reason for this is that if a send reply gets disturbed on the line the client is already resetting and can not resend the reply. Also, the reset may occur while the Reset Reply is still in the buffer to be sent. The host will know when a reset has occurred because the client will report an unacknowledged Stopped condition.

==== Emergency Stop (0x0C)

This Order causes the client to stop the print as fast as possible. All heaters will be turned of. PWM signals will be off (0% on cycle). Output signals will be off (= 0 = Low). If the firmware controls the motion (Stepper Control/Queued Command/Basic Move Extensions) then it must also stop all motion and remove all entries from the Queue. Stepper motors can be disabled (this will only happen if the firmware controls the stepper motors).

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| n/a | This command has no Parameter
|=============================

A Reset order is different to an emergency stop because a reset does not necessarily de-energise everything before resetting; whereas an emergency stop de-energises everything immediately.

An emergency stop must be accepted at any time.

.Replies
- OK: No Parameter data.

==== Resume (0x00)

This order will attempt to acknowledge or clear a stopped client condition. After initial power on or after reset the client will always assert a stopped condition which must be cleared using this command. Other error conditions can also trigger a stopped condition. The Resume Order ensures that the host is aware that the client has reset or stopped.

Typically a host will automatically acknowledge a Stopped condition so that it may continue to query the client or manipulate devices which do not pose a safety concern (for instance turning off cooling fans or warning LEDs when the device's temperature reaches safe levels again).

Conversely, a host might typically wait for user interaction before attempting to actually clear a Stopped condition.

A Stopped response is always returned for a Resume order if the client is still in a Stopped state after processing the order (for instance because the Resume order was only acknowledging the Stopped state or because the condition could not be cleared).

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | Acknowledge(0x0) / Clear(0x1)
|=============================

The first byte of the Parameter indicates whether the host wants to Acknowledge(=0) or Clear(=1) the stopped state.

.Replies
- OK: The Stopped state has been successfully cleared.
- Stopped: The stopped state was not cleared either because the condition persists, is unrecoverable or the Resume only requested that the Stopped state is acknowledged (see Reply Code description for content).

==== Request Information (0x01)

The requested Information is specified in the parameter as shown in the following table.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | Requestable Information
|=============================

.Requestable Information
[width="80%",options="header", cols="20%,60%,20%"]
|================================================
|Value| Information | Data Type
|   0 | firmware name string | string
|   1 | serial number string | string
|   2 | hardware name string | string
|   3 | given name/identity string | string
|   4 | major protocol version | int
|   5 | minor protocol version | int
|   6 | list of supported protocol extensions | int
|   7 | firmware type | int
|   8 | major firmware revision | int
|   9 | minor firmware revision | int
|  10 | hardware type | int
|  11 | hardware revision | string
|  12 | maximum supported step rate | int
|  13 | host timeout | int
| 0x80-0xfe | Experimental/unapproved requestable information | n/a
|================================================

NOTE: If a requested value is only expected to return a single integer value, then the length of the returned data indicates the length of the integer. For example, if 2 bytes are returned then the value should be interpreted as a 16-bit integer.

.Replies
- OK: The following notes describe the returned data for each requested item.

The *firmware name string* request returns a UTF8 character sequence that states the name and version of the Pacemaker client Firmware.

The *serial number string* contains a UTF8 encoded char sequence that contains
this client hardware's serial number. The serial number is optional. If no serial version
is available the client will response with an empty string (no bytes). The serial number is not guaranteed to be unique.

The *hardware name string* request returns a UTF8 character sequence that states the name and version of the Pacemaker client PCB.

The *given name/identity string* request a a UTF8 character sequence that states the name that the user has given to this device. This can be used to identify the correct board if two identical pacemaker client boards are used. The given name is optional. If no name has been given the client will respond with an empty sting(no bytes).

The *major protocol version* field defines which major version of the protocol is supported by the Pacemaker client. With each reworking of the protocol which makes the communication incompatible then the major version number will be increased. If the client supports more than one major protocol versions then each byte of the reply will contain one major protocol version number that is supported by the client.

The *minor protocol version* field also defines which minor version of the protocol is supported by the Pacemaker client. With each reworking of the protocol which does not make the communication incompatible then the minor version number will be increased. A higher number supported includes all lower numbered versions. So if minor Version 5 is supported by the client the minor Versions 1, 2, 3 and 4 must also be supported.

The *list of supported protocol extensions* lists the extensions that this firmware implements. See table "Protocol Extensions" in the section "Protocol Extensions" for details. Each byte of the reply holds one supported extension.

The *firmware type* defines the firmware family that this firmware belongs to. See Firmware Types table.

The *major firmware version* field defines which major version of the firmware is running on the Pacemaker client.

The *minor firmware version* field also defines which minor version of the firmware is running on the Pacemaker client.

The *hardware type* defines the Hardware Type. See Hardware Types table.

The *hardware revision* defines the Hardware revision.

The *maximum supported step rate* returns the maximum supported step rate of the client for any axis (in steps per second).

The *host timeout* returns the maximum allowed pause(in seconds) between two orders from the host. If the client detects a longer pause with no data arriving from the host the client will enter the stopped mode. This is a safety guard against a malfunctioning/crashed host application.

.Hardware Types
[width="50%",options="header", cols="30%,70%"]
|================================================
|Value| Hardware Type
|   0 | Pacemaker
|   1 | Generic Arduino based
|================================================

.Firmware Types
[width="50%",options="header", cols="30%,70%"]
|================================================
|Value| Firmware Type
|   0 | Pacemaker
|   1 | Minnow (Arduino based client implementation - https://github.com/minnow-pmc/Minnow )
|================================================

==== Request Device Count (0x11)

This order requests the number of available devices of a particular type (e.g., Heaters, Output Switches, Temperature Sensors) on the client. An advertised device may still be non-functional (as indicated by the Request Device Status order).

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
|=============================

.Replies
- OK: The Reply consists of a 1 byte unsigned integer number indicating the number of available devices of that type.
- Invalid Device Type: The requested device type is unknown or unsupported by the client.

==== Request Device Name (0x02)

This order requests the "friendly" name of the device. Normally this would return a value which matches the labeling on the board to allow a user to easily correlate the device number with the physical connector.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
| 1 | device number
|=============================

The first byte of the Parameter indicates the device type. The second byte of the Parameter indicates the desired device number.

.Replies
- OK: Utf8 string which indicates the human readable device name or an empty Parameter if no friendly name has been explicitly configured in the firmware.

==== Request Device Status (0x18)

This order indicates the operational status of the specified device. A host may also use this order to determine the state of devices after a stopped condition has occurred - different devices may be disabled depending on the nature of the stopped condition.

.Order Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
| 1 | device number
|=============================

The first byte of the Parameter indicates the device type. The second byte of the Parameter indicates the desired device number.

.Replies
- OK: The first byte of the Reply Parameter contains indicates one of the following values:

.Device Status values
[width="50%",options="header", cols="30%,70%"]
|=============================
| Value | meaning
| 0x0 | device active
| 0x1 | device inactive
| 0x2 | device disabled
| 0x3 | device configuration error
| 0x4 | device fault
| 0x5 | client stopped
|=============================

A status of *device active* indicates that the device currently has no detected hardware or configuration errors and has been enabled. The definition of "active" varies by device type. For instance:

- Steppers are active when enabled using the Enable Disable Stepper command.
- Output Switches are enabled when set to high.
- Pwm Outputs and Buzzer devices are active when set to a non-zero value.
- Heaters are active when set to a non-zero target temperature.
- Input devices such as temperature sensors and input switches are usually always active when configured correctly (indicating that they are available for reading).

A status of *device inactive* indicates that there are currently no detected hardware or configuration errors and the device is enabled but not active.

- Steppers are inactive when disabled using the Enable Disable Stepper command.
- Output Switches are inactive when set low.
- Pwm Outputs and Buzzer devices are inactive when set to a zero value.
- Heaters are active when set to a zero target temperature.

A status of *device disabled* indicates that there are currently no detected hardware or configuration errors but the device has been disabled.

- Steppers are disabled when deactivated through the Activate Stepper Control or through initial state.
- Output Switches are disabled when in the high impedance state.
- Pwm Outputs, Buzzer & Heaters devices are not typically disabled.

A status of *device configuration error* indicates that the device is not available for use because it has missing or invalid device configuration.

A status of *device fault* indicates that the device has sufficient configuration but is unavailable due to a detected hardware fault (e.g., unconnected or shorted sensor).

A status of *client stopped* indicates that the device has sufficient configuration and not in a fault state but is currently unavailable due to the client currently being stopped (this would be equivalent to the *device inactive* or *device disabled* status were the client not in a Stopped state).

A utf8 string may optionally follow the device status value describing the cause of any device errors.

==== Request Temperature Reading (0x03)

The requested temperature sensor(s) shall report their current temperature.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
| 1 | device number
| 2 | device type [Optional]
| 3 | device number [Optional]
| .. | [Optional]
|=============================

The first byte of the Parameter contains the device type (see Definitions), the second byte contains the number of the device. If more than one temperature sensor shall be read the next parameter bytes may contain additional pairs of device types and device number bytes.

Currently two device types support temperature readings: temperature sensor and temperature-controlled heater devices. When a temperature reading is requested on a heater device, then the order returns the temperature reading from either the explicitly associated temperature sensor (i.e., associated using the Configure Heater order) or from the internally configured temperature sensor.

.Replies
- OK: Reports the measured temperature in units of 1/10degree Celsius as a signed 2 byte integer. This means a value of 234 equals 23.4 degrees centigrade. The Value section of this data item is 2 bytes long for each requested sensor reading. Any reading which returns a value of 0x7FFF indicates that there is a problem with the temperature sensor. An optional utf8 string may follow the last temperature reading to return an error string for the first failed reading.

==== Get Heater Configuration (0x04)

This order reports the configuration state of the specified heater device.

On some clients there may be a permanent association between a heater and a temperature sensor. In these clients, sending the Configure Heater order is not required to explicitly provide that association.

.Order Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | heater number
|=============================

.Replies
- OK: The first byte indicates whether the heater has an internally configured temperature sensor configuration or not (0x0 = no, 0x1 = yes). If a temperature sensor association is internally configured (i.e., first byte equals 0x1), then a value of 0xFF in the second byte indicates that the temperature sensor is not advertised as a separate device or more than one temperature sensor is used (for instance); if there is no internal temperature sensor association, then a value of 0xFF in the second byte indicates that the heater has not been configured yet (with the Configure Heater order).

.Reply Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | internally configured temperature sensor [0x0 = no, 0x1 = yes]
| 1 | temperature sensor number (or 0xFF)
|=============================

==== Configure Heater (0x05)

This order configures an association between a temperature sensor and a heater device.

.Order Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | heater number
| 1 | temperature sensor number
|=============================

.Replies
- OK: Configuration accepted. No parameter data.

==== Set Heater Target Temperature (0x06)

This will activate the heater. The heater will heat up to reach the defined target temperature. To deactivate the heater set the target temperature to 0.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | heater number
| 1 | Target Temperature (MSB)
| 2 | Target Temperature (LSB)
|=============================

The first byte of the Parameter will contain the heater number. The following two bytes will contain the target temperature.

This order can also be queued using the Queue Command Wrapper if the queued command extension is supported.

.Replies
- OK:No Parameter data.
- Invalid Number Specified: the requested number is not correct for the heater.
- Invalid Parameter Value: Invalid set temperature.
- Device Unavailable: Cannot activate the heater because the client is in the Stopped state or the device has not been fully configured (e.g., an unconfigured temperature sensor) or is faulty. Use Get Device Status order to determine categorized cause (although a descriptive error string should also be returned in this reply).

==== Request State of Switch (0x07)

The Order shall report the state of the switch devices specified in the Parameter. The switch has two operational states which are: "Triggered/Active" (1) or "Not Triggered/Inactive" (0). These values do not necessarily map to the same voltage level on the input device pin. This arrangement provides a hardware abstraction to the host such that the host doesn't have to worry when the physical switch or wiring is normally open, normally closed, using active low, active high or requiring internal pullup.

The context about what it means for a particular switch device to be "Triggered/Active" or "Not Triggered/Inactive" will vary for different switch uses or device types.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
| 1 | device number
| 2 | device type [Optional]
| 3 | device number [Optional]
| .. | [Optional]
|=============================

The first byte of the Parameter contains the device type (see Definitions), the second byte contains the number of the switch/device. If more than one switch shall be read the next parameter bytes may contain additional pairs of device types and device number bytes.

.Replies.
- OK: Each byte of the reply Parameter will contain the state of the requested switch/device (0=Not triggered/Inactive, 1=Triggered/Active).
- Bad Parameter Value: This is returned if any specified device does not support this order.

==== Switch an Output (0x08)

This will switch the Output on one or more specified switch/devices to on(High/ 1/true), off(Low/0/false) or disabled (High-Z/2/Tri-state).

It should be realized that some devices use active low signaling/control and so some output switch devices may need to be configured to start in an "active" state during client power-on or when stopped (assuming that appropriate external pull ups are not provided by the controller hardware).

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
| 1 | device number
| 2 | state
| 3 | device type [Optional]
| 4 | device number [Optional]
| 5 | state [Optional]
| .. | [Optional]
|=============================

The first byte of the Parameter contains the device type (see Definitions), the second byte contains the number of the device. The third byte will contain the desired switch state. If more than one Output shall be switched at the same time, then the next bytes of the parameter may contain additional sets of Device Type, Device Number and State. (3 bytes per additional output)

.Output Switch State
[width="50%",options="header", cols="30%,70%"]
|=============================
| Value | Meaning
| 0 | low
| 1 | high
| 2 | disabled / high-impedance
|=============================

The client should return a failure without executing any of the requested changes if any one of the requested changes is invalid.

This order can also be queued using the Queue Command Wrapper if the queued command extension is supported.

.Replies
- OK: No Parameter data (used when immediate execution is requested).
- Invalid Device Type: This is returned if any specified device does not support this order.

==== Set PWM Output Value (0x09)

This will set the average on-time value of the specified PWM outputs (e.g., fans). The PWM on-time value is represented as a 16-bit value: 0x0000 indicate 0% on time; 0xFFFF indicates 100% on time.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | device type
| 1 | device number
| 2 | PWM (MSB)
| 3 | PWM (LSB)
|=============================

The first byte of the Parameter contains the device type (see Definitions), the second byte contains the number of the device. The third and fourth byte will contain the 16-bit PWM value. If the client has only 8bit PWM then the client can ignore the lower 8 bits (fourth byte = LSB).

This order can also be queued using the Queue Command Wrapper if the queued command extension is supported.

.Replies
- OK: No Parameter data (used when immediate execution is requested).
- Invalid Device Type: This is returned if any specified device does not support this order.

==== Set Output Tone (0x1c)

This order will generate an audio tone of the specified frequency on the specified output device (e.g., buzzer devices). Setting a value of 0 will stop the tone generation thereby deactivating the device. The output level when the device is deactivated can be assumed to be the logic level zero unless explicit firmware configuration specifies otherwise.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length in Bytes| Content
| 1 | device type
| 1 | device number
| 2 | frequency (in hertz)
|=============================

The first byte of the Parameter contains the device type (see Definitions), the second byte contains the number of the device. The third and fourth byte specify the target output frequency specified in hertzs.

This order can also be queued using the Queue Command Wrapper if the queued command extension is supported.

.Replies
- OK: No Parameter data (used when immediate execution is requested).
- Invalid Device Type: This is returned if any specified device does not support this order.
- Invalid Device Number: The requested device is not available.

==== Write Firmware Configuration Value (0x0A)

This command sends a configuration name and value to the firmware. The host should only send a configuration that it knows the firmware supports. The top level format for the command is as follows:

[width="50%",options="header", cols="30%,70%"]
|================================================
| Length in Bytes | Parameter Contents
| 1 | length of configuration name [==M]
| M | name of configuration (utf8 string)
| any | value of configuration to set (utf8 string)
|================================================

The supported names and the expected values are firmware dependent. All configuration names and value are encoded as utf8 strings. If the parameter name is unrecognized or the value is malformed then a Bad Parameter Value error is returned. If the value is valid but the operation fails then a Failed error response is returned.

NOTE: The client must ensure that writing the same value to a Volatile or Non-Volatile Configuration item more than once does not return failure on subsequent writes (even if the underlying value is one-time configurable). This is so that the host does not need to reset the client to reapply config.

.Example
Setting the configuration named "Power" to "on" would result in this parameter value:

.Parameter of Power = on
[width="50%",options="header", cols="30%,15%,55%"]
|=============================
|Byte Number | Value | Meaning
| 0 | 0x05 | length of Configuration name
| 1 | 0x50 | 'P'
| 2 | 0x6f | 'o'
| 3 | 0x77 | 'w'
| 4 | 0x65 | 'e'
| 5 | 0x72 | 'r'
| 6 | 0x6f | 'o'
| 7 | 0x6e | 'n'
|=============================

.Replies
- OK: Successful write.
- Bad Parameter Value: Bad configuration name.
- Failed: Bad or rejected configuration value.

==== Read Firmware Configuration Value (0x0B)

This command reads configuration data from the firmware. The supported configuration name and the returned values are defined by the specific firmware; however all configuration names and values are encoded as UTF8 strings. See the firmware documentation for details.

The Parameter simply contains the name of the configuration value to read as a utf8 string.

.Example
Reading the configuration named "Power" would result in this parameter value:

.Parameter of Power
[width="50%",options="header", cols="30%,15%,55%"]
|=============================
|Byte Number | Value | Meaning
| 0 | 0x50 | 'P'
| 1 | 0x6f | 'o'
| 2 | 0x77 | 'w'
| 3 | 0x65 | 'e'
| 4 | 0x72 | 'r'
|=============================

.Replies
- OK: Successful read. Parameter contains value as a utf8 string.
- Bad Parameter Value: Bad configuration name
- Failed: Read operation failed

==== Get Firmware Configuration Value Properties (0x1a)

This command allows the read properties of a firmware configuration element.

.Order Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length | Content
| N | Configuration element name
|=============================

.Replies
- Bad Parameter Value: Bad/unknown configuration name.
- OK: The Reply Parameter contents is as follows:

.Reply Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length | Content
| 1 | Element type
| 1 | Element modes
| 1 | Device Type
| 1 | Device Number
|=============================

.Element Type
[width="50%",options="header", cols="30%,70%"]
|=============================
| Value | Meaning
| 0 | Volatile Configuration. These configuration element values will not be retained after a reset. These elements are expected to be both readable and writeable.
| 1 | Non-volatile Configuration. These configuration element values will be retained after a reset. Read-only non-volatile configuration elements indicate a compile-time client configuration value.
| 2 | Status & Statistics. These elements indicate aspects of the run-time state of the client (if readable), or are used to manipulate/reset the status and statistics values (if writeable).
| 3 | Firmware-specific operation. These elements are used to invoke firmware-specific operations.
| 4 | Diagnostic & Debug. These elements are used to aid development of debugging of the client system.
| 0x80-0xfe | Experimental
|=============================

.Element Modes
[width="50%",options="header", cols="30%,70%"]
|=============================
| Bit Position | Meaning
| 0 (lsb) | Element readable? (0 = Not readable, 1 = Readable)
| 1 | Element Writeable? (0 = Not Writeable, 1 = Writeable)
| 2 | Default value? (0 = No, 1 = Yes). This indicates that the configuration value has not been explicitly set and that this is the compile-time default value currently in use.
|=============================

The Device Type and Device Number fields will return non-zero values if the firmware configuration element is associated with a particular device instance. This mechanism allows a host program to display the firmware configuration items associated with particular devices should it choose to.

The host should be able to restore the dynamic configuration state of a client following a reset by re-applying all "Dynamic Configuration" element values. Note: this does not imply that restoring the dynamic configuration elements will also restore all dynamic and protocol-controlled runtime state.

==== Traverse Firmware Configuration Values (0x1b)

This command allows the host to traverse all firmware configuration values supported by the client. This allows the host to save a copy of the current client configuration and also allows the host to provide a richer configuration interface to the user.

The configuration element list is traversed by supplying the next Traverse Firmware Configuration Values order with the configuration element name returned by the last Traverse Firmware Configuration Values order. Specifying an empty Parameter will start the traversal again.

Note: the firmware configuration values will often represent the dynamic state of the client's configuration and so setting firmware values (such as configuring a new peripheral device using the Write Firmware Configuration Value Order) may cause the set of elements returned by the Traverse Firmware Configuration Order to change.

If a Write Firmware Configuration Value order is sent in the middle of traversing the firmware configuration list, then this may result in a Bad Parameter Value error being returned by the Traverse order (in this case the traversal should start from the beginning again).

.Order Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length | Content
| N | Last configuration element name traversed (or empty Parameter to restart traversal)
|=============================

.Replies
- Bad Parameter Value: Bad/unknown configuration name. This can occur if a Write Firmware Configuration Value order removes or invalidates an element during a traversal.
- OK: The Reply Parameter contents is as follows:

.Reply Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length | Content
| N | Next configuration element name (utf8 string)
|=============================

The end of the configuration traversal is indicated by the order returning an empty element name.

==== Experimental & Unapproved Orders
Experimental or unapproved orders must use order codes from the range 0x80 to 0xfe. Experimental or unapproved orders that need additional order-specific Reply Codes should use Reply Code values of 0x80-0xfe.

== Stepper Control Extension

=== Description

The minimal Pacemaker client does not need to be able to control stepper motors. If it is able to control stepper motors than this extension provides the Orders the host can use.

=== Managing End-stops

The Pacemaker protocol supports the use of end-stop switches to halt unexpected carriage movement - the client enters a Stopped state if the end-stops are enabled and movement occurs in a direction towards the end-stop after homing. However, when using this functionality, the host implementation must take into account that moving a carriage to near the home position can also cause the end-stop to trigger.

The host can manage this in one of the following ways:

a. prevent the carriage moving all the way to the home position except when homing
b. move the carriage away from the end stop a fixed distance after the home axis order completes
c. disable the end-stop whenever the carriage needs to move all the way to the end-stop position and re-enable when it moves away.

=== End-stop behavior

The Configure End-stop order allows the host to configure the set of end-stop switches which are checked when each stepper is moving in a particular direction (positive or negative - with different end-stops being possible for each direction). In printers with CoreXY and H-bot drive systems (for instance) then multiple end-stops may need to be checked for a particular stepper direction and a particular end-stop may need to be checked for multiple steppers.

During non-homing movement commands, the client will monitor all enabled and applicable end-stops (as determined by the direction of the movement) and if any of these end-stops matches their triggered state, then the client will enter the "End-stop hit" Stopped state.

When the client enters an "End-stop hit" Stopped state then:

- all movement is halted,
- all heaters are deactivated,
- all other outputs are deactivated (The firmware may be configured to do otherwise to have devices operating that protect the printer)
- the order queue is flushed,
- the stopped state is asserted.

However when the movement is performed with the "homing mode" bit set, if any enabled and applicable end-stops trigger, then the stepper devices specifying this end-stop will stop their movement but the other stepper devices will continue moving. The client will not enter the "End-stop hit" stopped state.

=== Orders

==== Activate Stepper Control (0x0D)

This defines who is controlling any attached stepper motors. If the client supports sharing the control of stepper devices with an external entity, then this command is used to indicate whether or not the client is currently in control. If Stepper Control is activated on this client, then the control is assumed exclusive (simultaneous control from two devices is not supported). If the client supports shared stepper control, then the default power-on/reset state for the stepper control is to be deactivated.

NOTE: Not all Pacemaker clients can support the deactivation of stepper control. In this case, the client's steppers will start in an activated but inactive/disabled state. If the host discovers that a client starts with its steppers in an "inactive" state after reset (as reported by the Request Device Status order) then the host should assume that deactivation of stepper control is not supported.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | Control Stepper motors
|=============================

If the first byte of the parameter is 0x0 then the Pacemaker client will not control the Stepper motors directly. If the first byte of the Parameter is 0x1 then the Pacemaker client firmware will control the stepper motors.

.Replies
- OK: No Parameter data.
- Busy: Order received when Order Queue is not empty.
- Stopped: Order rejected because client is in stopped stated.

==== Enable / Disable Stepper Motors (0x0E)

This will disable the stepper drivers so that the Axes can be moved manually.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | stepper motor number [Optional]
| 1 | status [Optional]
|=============================

If a Parameter is provided the first byte will contain the stepper motors Number. The second byte will provide the new status of the motor. A value of 1 means enabled. A value of 0 means disabled. If no Parameter is provided all stepper motors will be disabled. The stepper motors will be enabled automatically with each command that needs to move them. This command is only allowed if the stepper control has been activated!

This order can also be queued using the Queue Command Wrapper if the queued command extension is supported.

.Replies
- OK: No Parameter data.
- Incorrect mode: Order received when stepper control is not activated.
- Device Unavailable: Cannot activate the stepper because the client is in the stopped state or the device has not been fully configured or is faulty. Use Get Device Status order to determine categorized cause (although a descriptive error string should also be returned in this reply).


==== Configure End-stops (0x0F)

This order configures the set of end-stop switches which are checked when the specified stepper is moving in either a positive or negative direction.

All end-stops (including both maximum and minimum) for a single stepper number must specified in the same order. Multiple end-stops can be specified for each direction. End-stops are initially disabled and must still be enabled using the Enable/Disable End-stops order before they will cause the end-stop state to affect movement.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|================================================
| Length in Bytes | Parameter Contents
| 1 | stepper number
| 1 | input switch number
| 1 | min or max endstop (0 = min endstop, 1 = max endstop)
| 1 | input switch number [optional]
| 1 | min or max endstop (0 = min endstop, 1 = max endstop) [optional]
|================================================

After the first byte (identifying the target stepper number), the following Parameter data is made up of byte pairs each of which configures an end-stop to be checked (if enabled) when the stepper is moving in the specified direction. More than one stepper can share the same end-stop - which is common in a CoreXY configuration.

.Replies
- OK: No Parameter data.

==== Enable/Disable End-stops (0x10)

The host enables or disables end-stops using this order. Attempting to enable an end-stop which hasn't been enabled with Configure End-stops will result in an error.

The order Parameter consists of byte pairs which specify an end-stop device number and whether the end-stop is to be enabled or disabled.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
| Length in Bytes | Content
| 1 | input switch number
| 1 | enabled state (0 = disabled, 1 = enabled)
| 1 | input switch number [optional]
| 1 | enabled state (0 = disabled, 1 = enabled) [optional]
|=============================

This order can also be queued using the Queue Command Wrapper if the queued command extension is supported.

.Replies
- Bad Parameter Value: If any end-stop is enabled which hasn't been configured using Configure End-stops.
- Incorrect mode: Order received when stepper control is not activated.

== Queued Command Extension

=== Description

When the client is being used to directly control movement then the throughput of individual moves will mean that batched delivery and queuing is usually highly desirable. This extension therefore implements the functionality required to transmit and enqueue multiple "Command Blocks" in a single Order frame.

In addition to basic movement commands, there are other non-movement orders which also need to be synchronized with the stepper-motor movement for effective machine control. Some examples of queue command blocks include linear moves, a delay and certain queue-compatible standard orders such as writing to output switches and PWM devices.

=== Queuing of Commands and Movement

The queue is assumed to consist of a ring buffer of "queue slots" (although internal implementation may use a contiguous memory block). The Order Queue can also hold non-movement commands like changing switch output values or fans speeds as these often need to be synchronized with toolhead movement.

The host should be aware that complicated commands may take up more than one queue slot; however, the host can assume that a short linear move block command which includes up to 4 moving axes (e.g XYZ & 1 toolhead) will fit into a single queue slot.

The number of remaining free slots is reported in the reply for an Order which was queued. This allows the host to determine how many more commands or movement blocks it can send.

The host should not assume that the current number of remaining queue slots is exactly equal to the initial number of queue-slots minus the currently queued number of commands. The exact amount of space to store each command varies depending on the implementation and may also be affected by the use of ring buffer algorithms. Luckily, each queue-related command reports the remaining number of command slots. The number of commands remaining in the queue can also be polled by sending an empty Enqueue Command Blocks order.

=== What Orders Can Be Queued?

This extension supports a special command block called "Queue Command Wrapper" which can be used to wrap and enqueue a normal Order frame into the queue. This is provided so that these queue-compatible orders can be efficiently synchronized with movement without needing to duplicate functionality on the client.

It should be noted that the "Queue Command Wrapper" will not accept arbitrary Order frames. Accepted Orders need to have a particular set of properties to be appropriate for queuing:

- the Order cannot expect to return data in the Reply
- the Order must not be expected to return failure
- the Order must explicitly state in its description that it supports the use of the "Queue Command Wrapper"

If the operation requested by the Order might not be successful (as opposed to the Order itself), then the Order description must define an alternative (and definitive) mechanism the host can use to detect this failure (e.g., through events or by reading device state).

=== Validation Before Queueing

Before command blocks are queued, the client should perform reasonable validation of the command block data. For instance, if a "Switch Output" Order is received (using Queue Command Wrapper) where one of the requested devices is invalid, then this command block should generate an "Invalid Device Number Specified" error before being enqueued rather than when it is executed off the enter of the queue.

=== Extension Orders

==== Clear Command Block Queue (0x17)

This order gracefully flushes the command block queue. If the client is currently moving, then the client will attempt to come to a graceful stop at the end of the first movement block where this is possible (for instance by decelerating from the nominal rate using the configured underrun avoidance acceleration rate). Once the client is stopped at the end of a movement block - or was stationary to start with - then all remaining items in the command queue are flushed.

For consistency, the order reply returns the same information as the reply for the Queue Command Block order. It should be remembered that the reply to the Clear Command Block Queue order is sent immediately and so therefore the Clear Command Block Queue reply will usually indicate that the queue is not empty (unless the queue was already empty when the order arrived). The host should poll the queue count using Queue Command order (for instance) to determine when the queue is empty and the system stopped.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| n/a | This command has no Parameter
|=============================

.Replies
- OK: The order has been accepted. Bytes 1 & 2 of the Reply parameter indicates the number of move block queue slots are available. Bytes 3 & 4 indicate the number of commands in the queue including any commands currently executing. Bytes 5 & 6 (a rolling 16-bit integer) indicates the number of executed command blocks since the last Stopped state was cleared.

.OK Reply Parameter Content
[width="50%",options="header", cols="30%,70%"]
|============================
| Length in bytes | Content
| 2 | Number of queue slots available
| 2 | Number of currently commands in queue including any commands currently executing
| 2 | Number of executed command blocks since last the last Stopped state was cleared (a rolling 16-bit integer).
|============================

See the Queue Command Blocks order for a description of these reply parameter values.

==== Queue Command Blocks (0x12)

This order adds new command blocks to the Pacemaker command queue. If the client cannot queue all requested command blocks then it must reply with an Order Specific Error reply as described below but it _may_ still queue an initial portion of the command blocks (in which case the Error reply will indicate the number of successfully queued blocks). The reply will also contain the number of free slots in the queue.

If the client detects an error in any requested command block then it must reply with the Order Specific Error reply as described below. In this case the client may queue previous command blocks but must not queue command block following the errored block.

The Parameter contains the sequence of command blocks.

.Order Parameter
[width="50%",options="header", cols="35%,65%"]
|============================
| Length in bytes | Content
| 1 | Length of block 0 in bytes (N)
| 1 | Command block type for block 0
| N-1 | block 0 data
| 1 | Length of block 1 in bytes (M)
| 1 | Command block type for block 1
| M-1 | block 1 data
|  .. | ..
|============================

Each block begins with a length byte and a command block type: the length byte indicates the number of following bytes in the block (including the command block byte) and the command block byte indicates the command block type. The currently defined movement block types are described in the next section (along with the associated extension).

If an empty Parameter is sent then no orders are queued but the order reply is sent as usual (which can be used to monitor print progress).

NOTE: if a queued command blocks is currently being executed, then this is treated as still being in the queue for the purposes of counting available queue slots and command blocks queue counts.

[NOTE]
=====================================================================
the reply to this order contains a count of the executed command blocks since the last Stopped state was cleared. This rolling 16-bit value can be used to determine the state of the system after this command is issued or a Stopped state entered. For the purposes of this count:

- Each movement block counts as 1 command. All other queued orders also count as 1 command.
- The count of executed command blocks does not include command blocks which failed validation (and therefore were not inserted in the queue) or were flushed from the queue before execution.
- The count does include all command blocks for which execution was attempted - regardless of whether or not they were successful.
=====================================================================
.Replies
- OK: All blocks were queued successfully. Bytes 1 & 2 of the Reply Parameter indicates the number of move block queue slots are available. Bytes 3 & 4 indicates the number of command blocks currently in queue. Bytes 5 & 6 (a rolling 16-bit integer) indicates the number of executed command blocks since the last Stopped state was cleared.

.OK Reply Parameter Content
[width="50%",options="header", cols="35%,65%"]
|============================
| Length in bytes | Content
| 2 | Number of queue slots available
| 2 | Number of command blocks currently in queue including any commands currently executing
| 2 | Number of executed command blocks since last the last Stopped state was cleared (a rolling 16-bit integer).
|============================

- Order Specific Error: Sent if the entire Order wasn't successfully enqueued. The Parameter content is as follows:

.Error Reply Parameter Content
[width="50%",options="header", cols="35%,65%"]
|============================
| Length in bytes | Content
| 1 | Cause: 0x1 = Queue Full, 0x2 = Unknown Command Block Type, 0x3 = Malformed Block, 0x4 = Error in command block
| 1 | Number of command blocks successfully enqueued from order
| 2 | Number of queue slots available
| 2 | Number of currently command blocks in queue including any commands currently executing
| 2 | Number of executed command blocks since last resume (a rolling 16-bit integer).
| 1 | Error Reply Code or 0xff
| N | Error Parameter data / Error Reason [Optional]
|============================

The *Cause* indicates whether the error was caused by the queue being full, an unknown command block type, or an error in the command. If a command block has insufficient bytes then an "Error in command block" should be indicated with Malformed Parameter Value as the Reply Code in byte 8.

The *Number of command blocks enqueued* indicates the number of command blocks from the order which were successfully queued. The error information in this reply will always relate to the following command block.

The *Number of executed command blocks since last resume* is a rolling 16-bit integer which indicates the total number of command blocks where execution was attempted since the last resume.

The *Number of queue slots available* indicates the remaining queue slots available.

The *Error Reply Code* value indicates the reply code of the errored command block as though the command was executed directly. This byte normally has a value of 0xff except for "Error in command block" type errors. An error reply code of 0xff indicates that the following byte is the start of an error string rather then reply parameter data.

The *Error Parameter data* value (if present) indicates the parameter data of the errored command block as though the command was executed directly. If the Error Reply Code is equal to 0xff then this should simply be interpreted as a utf8 error string.

=== Currently Defined Command Block Types

The currently defined movement block types are described below along with the associated extension.

[width="75%",options="header", cols="40%,60%"]
|============================
|Command Block Type Value | Command Block Type Name And Extension
| 0x1 | Queue Command Wrapper [queued command extension]
| 0x2 | Delay [queued command extension]
| 0x3 | Basic Linear Move [basic move extension]
| 0x4 | Set Active Toolhead [basic move extension]
| 0x5 | Movement checkpoint [basic move extension]
| 0x80 - 0xfe | Experimental or Unapproved Command Blocks
|============================

=== Basic Command Block Definitions

==== Queue Command Wrapper (0x01)

This command block is a wrapper which allows a standard order to be inserted into the command queue. For instance, it allows the "Switch an Output" order to be enqueued.

Support for queueing must be explicitly indicated in the order description.

Orders supporting queuing should not expect to fail and cannot return information in the Reply.

.Command Block Contents
[width="50%",options="header", cols="30%,70%"]
|=============================
|Length In Bytes | Content
| 1 | Command Block Type Byte (== 0x01)
| 1 | Order Code
| N-2 | Order Parameter data (where N is the value in the length byte for the block)
|=============================

If the requested Order Code is not a permitted order code for queueing, then the client should return a "Unknown Order" Code in the Error Reply Code of the Queue Command Blocks order.

==== Delay (0x02)

This command block will enqueue a delay.

.Command Block Contents
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | Command Block Type Byte (== 0x02)
| 1 | delay (MSB)
| 2 | delay (LSB)
|=============================

The Delay command block has 2 bytes of additional block content containing an integer indicating the time to delay. This delay is measured in units of 10us. The client does not need to implement a high-accuracy timer but must ensure that it delays at least this long.

== Basic Move Extension

=== Description

This extension is intended to allow a client which needs to directly drive the system's stepper motors to provide the necessary movement control to implement CNC and/or 3D printer functions.

NOTE: The active orders in this extension all require that stepper control is activated. The extension also assumes that the Queued Command Extension is implemented.

=== Movement modelling

The basic move extension defines the basic linear movement block type.

Each movement block describes the movement of all selected axes for a specific period of time. One of the selected axes is used as the primary axis. The movement block specifies the speed and acceleration/deceleration on the primary axis. The movement of all other axes undergoes the same acceleration and deceleration such that the requested steps on all other axes are generated to be evenly distributed (in distance not time) along the path of the primary axis.

The encoding of the movement block has been optimized to allow a large number of short linear segments to be queued and executed with a minimum of serial bandwidth and CPU overhead. Each block defines a trapezoidal speed function, that is, accelerate to a nominal speed, move at nominal speed, then decelerate to an end speed.

This basic linear movement modelling is similar to the stepper control used in printer firmware such as Marlin or Grbl.

Other movement block types can be defined in later extensions as required, for instance, to support simultaneous movement of multiple toolheads, to support independent speed control on different axes, or to support asynchronous movement commands.

=== Design Rationale For Movement

==== What assumptions does the protocol make about stepper movement?
The basic linear move command assumes that the same acceleration can be applied to all travel axes and a linear path will still be followed. This assumption is true for Cartesian and CoreXY machine configurations - other configurations are discussed below.

The current basic move order also assumes that a separate speed specification is not needed for each axis. Speed of the toolhead in three-dimensional space can be controlled by specifying a single desired step rate on the primary axis and controlling the relative number of steps in each other axes of movement. [Remember that each movement block describes the movement for the same time period.]

==== What about delta and polar bots?
Delta and polar co-ordinate systems require a non-linear step-rate generation in order for the toolhead to trace a linear path. These non-linear calculations can be quite expensive to perform on small processors.

There are two recommended approaches for implementing these type of machine configurations with Pacemaker:

- One common approach (such as used by Marlin) is to break each linear toolhead movement command (in Cartesian space) into the large number of small "linear step-rate" movement segments which are sent to the stepper controllers. Each segment will not trace a perfectly linear path but because the segment sizes are very small then this is usually not noticeable. Pacemaker enhances this approach because it has been specifically optimized to transport and execute many small linear segments. CPU-limited real-time printer controllers (e.g., Arduino) are limited in the number of times they can be performed these calculations per second. With Pacemaker, the movement planning is done on the host (typically much faster than the client) and so the number of segments which can be generated per second is likely to be higher (in this case). This makes the Pacemaker solutions far more suitable to these non-linear co-ordinate systems than many of the existing systems.

- Another approach is that the client simply presents itself to the host as a Cartesian machine and then performs all conversion to polar or delta co-ordinate systems within the firmware.

==== What about non-linear extruder advance algorithms?
Some printers use extruder advance algorithms to non-linearly modify the extrusion rate based on parameters like toolhead speed.

The Pacemaker framework has been specifically optimized to allow non-linear behaviors to be efficiently implemented using sequences of short linear segments. Similarly to implementing non-linear movement in the XYZ axes (for delta or polar bots), this technique can also be used for implementing non-linear advance algorithms in the extruder axes. The advantage of this approach is that the client requires no additional logic to implement an arbitrary advance scheme.

==== What happens if the communication is disrupted during movement?
An underrun avoidance algorithm can be implemented to reduce the maximum speed when a disruption is anticipated, for instance, a limited number of movement blocks remain in the command queue and the host has not inidcated that this is the end of movement. The underrun avoidance algorithm also ensures that missed steps do not occur as the result of a queue underrun.

The details of the algorithm are discussed in more detail in the Basic Movement Extension.

=== Recovery after stop

The protocol currently doesn't require the client to track the position of each axis and therefore doesn't include a "get position" command. However, in situations other than an emergency stop or a Stopped state (where steps might have been missed anyway), the host should be able to determine the position on all axes by simply knowing how many command blocks have been executed.

The client always returns an executed command block count in the "Queue Command Block" Reply Parameter which can be used to determine position even after a orderly "Clear Command Block Queue" command has been issued. The executed command block count is a count of all command blocks which have attempted execution (including those which encountered an error) since the last Stopped state was cleared.

An emergency stop will require the host to re-home axes to determine its position - an emergency stop and certain other Stopped errors can result in skipped steps. Thus even if the client maintained an exact step count in these cases, it wouldn't necessarily be accurate.

=== Extension Orders

==== Configure Axis Movement Rates (0x13)

This specifies a 4-byte maximum movement rate value (in steps per second) for each stepper. This value is used when the stepper is selected as the primary axis for a linear move command block.

A stepper must be configured with a non-zero maximum movement rate before it can be selected as a primary axis in a linear move block.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
| Length In Bytes | Content
| 1 | stepper number
| 4 | max steps per second
|=============================

.Replies
- OK: No Parameter data.
- Busy: Order received when Order Queue is not empty.
- Incorrect mode: Order received when stepper control is not activated.
- Invalid Parameter Value: Requested step rate exceeds maximum supported by client.

==== Configure Movement Underrun Avoidance Parameters (0x19)

This order configures the parameters for the underrun avoidance algorithm. This algorithm comes into play when the client believes that a movement queue underrun is likely to occur, that is, the command queue will be exhausted without a movement checkpoint command being received.

An example underrun avoidance algorithm is as follows:

- if the client determines an underrun is likely, then the client will decelerate at the specified rate until the movement rate equals the lower of the nominal movement rate or the specified underrun avoidance maximum movement rate
- the client will then limit the movement rate to be less than or equal to the specified underrun avoidance maximum movement rate until the enqueued remaining movement time (at nominal speed) exceeds the specified minimum period.
- the client will accelerate back up to the nominal speed at the specified rate when the movement queue refills beyonds the specified minimum period or a movement checkpoint is received.
- the aglorithm will also gracefully decelerate to a stop coinciding with the point where the movement queue is exhausted.

TBD: discuss parameters for entering underrun mode

A client may also choose to implement a simpler underrun avoidance algorithm which simply ensures that the there are no missed steps when an underrun occurs (i.e., the client will decelerate gracefully to a stop at that point). This should be adequate in situations where an underrun is extremely unlikely, for instance, where the Pacemaker host and client are directly connected and the nature of the host makes it unlikely to be blocked for any substantial period.

As usual, acceleration/deceleration and maximum movement rates used by the underrun avoidance algorithm are slected by the currently specified primary axis. A set of maximum movement rates and acceleration values must therefore be specified for each possible axis. Remaining queued movement time also includes other commands which take non-negligible time such as the Delay command block (0x02).

A stepper must be configured to have non-zero underrun maximum movement and acceleration/deceleration rates before it can be selected as a primary axis in a linear move block.

.Parameter
[width="50%",options="header", cols="30%,70%"]
|=============================
| Length In Bytes | Content
| 1 | stepper number
| 4 | maximum movement rate (in steps per second) during underrun avoidance
| 4 | acceleration/deceleration rate for underrun avoidance (in steps per second per second)
|=============================

.Replies
- OK: No Parameter data.
- Busy: Order received when Order Queue is not empty.
- Incorrect mode: Order received when stepper control is not activated.

=== Queue Command Block Definitions

==== Basic Linear Move (0x03)

Each basic linear movement block specifies a trapezoid speed profile, that is, accelerate to nominal speed, move at nominal speed, then decelerate to end speed.

Each block includes the following information:

* the axes involved in the move
* the direction and total number of steps on each axis
* the primary axis to use for movement rate values
* a desired nominal speed
* a desired end speed
* a step count to reach nominal speed (which conveys an initial nominal acceleration rate)
* a step count to reach final speed (which conveys the final deceleration rate)

The nominal starting speed for each block can be deduced from end speed of the previous movement block; queue underrun avoidance algorithms however may mean that the actual starting speed when executed is different to specified speed.

The command supports up to 15 stepper axes.

===== Format Examples:

.1 byte axis selection bitmask format (allows up to 7 axes)
[width="75%",options="header", cols="30%,70%"]
|============================
| Length in Bytes | Content
|   1 | Command Block Type Byte (== 0x03)
|   1 | bit7: 1 or 2 byte axes format: 0 (= 1 byte format) *[Axis Selection Field]*
|     | bits6-0: axes used in block (assume n bits set in this example)
|   1 | bit7: use 1 or 2 byte step counts (0=1 byte, 1=2 byte) *[Directions Field]*
|     | bits6-0: direction on each axis
|   1 | bits3-0: primary axis selector
|     | bit4: homing mode (0 = no, 1= yes)
|   1 | nominal speed fraction
|   1 | end speed fraction
| 1 or 2 | initial acceleration step count [2 bytes if bit 15 of Directions Field is 1; 1 byte otherwise]
| 1 or 2 | final deceleration step count
| 1 or 2 | steps on first selected axis [2 bytes if bit 15 of Directions Field is 1; 1 byte otherwise]
| 1 or 2 | steps on second selected axis
| 1 or 2 | steps on third selected axis
|  .. | ..
| 1 or 2 | steps on n'th selected axis
|============================

.2 byte axis selection bitmask format (allows up to 15 axes)
[width="75%",options="header", cols="30%,70%"]
|============================
| Length in Bytes | Content
|   1 | Command Block Type Byte (== 0x03)
|   2 | bit15 = 1 or 2 byte axes format: 1 (= 2 byte format) *[Axis Selection Field]*
|     | bits14-0: axes used in block (assume n bits set for example)
|   2 | bit15: use 2 byte step counts (0=no, 1=yes) *[Directions Field]*
|     | bits14-0: direction on each axis
|   1 | bits3-0: primary axis selector
|     | bit4: homing mode (0 = no, 1= yes)
|   1 | nominal speed fraction
|   1 | end speed fraction
| 1 or 2 | initial acceleration step count [2 bytes if bit 15 of Directions Field is 1; 1 byte otherwise]
| 1 or 2 | final deceleration step count
| 1 or 2 | steps on first selected axis [2 bytes if bit 15 of Directions Field is 1; 1 byte otherwise]
| 1 or 2 | steps on second selected axis
| 1 or 2 | steps on third selected axis
|  .. | ..
| 1 or 2 | steps on n'th selected axis
|============================

The *Axis Selection Field* does a couple of things: the MSB indicates whether a 1 or 2 byte axis selection bitmask will be used, then the remaining 6 bits contains the axis selection bitmask which indicates the stepper number indexes which will be moving in this block. For instance, if bit 2 is set, then stepper number 2 will be moved in the current movement block. If bit msb of the Axis Selection Field is equal to 1, then the first two bytes of the movement block should be consider as making up the axis selection bitmask (supporting up to 15 axes instead of 6 axes).

The *Directions Field* is another bitmask field where each bit defines the direction of movement and uses the same axis to bit position mapping as for the axis selection bitmask. For example, bit 0(LSB) contains the direction of stepper number 0 movement. A "1" means moving in increasing direction. If a 2 byte axis selection bitmask is used, then a 2 byte directions field is also used. The MSB of the Directions field indicates whether 1 or 2 byte step counts will be used.

The *primary axis selector* indicates the stepper axis number of the primary axis for this movement command. The speed and acceleration are calculated with respect to the primary axis for the movement block. The selected primary axis must be one of the axes involved in the current movement block. It is recommended that the primary axis is selected to be the travel axis with the highest movement rate (in steps per second) for the movement block.

NOTE: The host has to make sure that the other axes do not get more steps than they can handle. The client does not need to check if the move command causes valid acceleration and valid speeds on all axis.

The *homing mode* bit indicates how the movement is affected by end-stop triggering. If the homing mode is not set, then any if relevant end-stops triggers (i.e., end-stops which are associated with the direction of movement of all selected axes), then the system will immediately enter a "End-stop Hit" stopped state. If the homing mode bit is set, then the client will simply stop movement in any axis when an enabled end-stop is triggered but continue movement in all other axes (until either an end-stop is hit or the command block movement is completed).

The *nominal speed fraction* is the desired movement speed after initial acceleration. It is expressed as a fraction of the configured maximum speed for the primary axis (where 0 = 0% and 255 = 100%). The nominal speed must always be specified as greater than or equal to the implied initial speed and the specified final speed.

The *end speed fraction* is the desired movement speed after all primary axis steps have been taken. It is expressed as a fraction of the configured maximum speed for the primary axis (where 0 = 0% and 255 = 100%).

The *initial acceleration step count* is the number of steps on the primary axis which are taken to accelerate from the starting speed to the nominal speed. This allows control of the acceleration rate of the linear move. This is a 1 byte unsigned integer if 1 byte step counts are being used; otherwise it is a 2 byte unsigned integer.

The *final deceleration step count* is the number of steps on the primary axis which are taken to decelerate from the nominal speed to the end speed (at the end of the movement block). For instance, a value of 30 for a 200 step movement block would mean that after 170 steps on the primary axis the client starts to decelerate to the end speed. This allows control of the deceleration rate of the linear move. This is a 1 byte unsigned integer if 1 byte step counts are being used; otherwise it is a 2 byte unsigned integer.

If the movement block is accelerating for the entire time, then the nominal & end speed should be set equal and the deceleration step count set equal to 0. If the movement block is decelerating for the entire time, then the nominal speed should be set equal to the (implied) initial speed and the acceleration step count set equal to 0.

The steps on each of the selected axes are always specified as unsigned step count values (indicating movement not position). The step counts in each movement block are always specified in order of the stepper number index but it only includes selected axes for the block. This is a 1 byte unsigned integer if 1 byte step counts are being used; otherwise it is a 2 byte unsigned integer.

The steps on the other selected axes are simply generated to be evenly distributed (in distance not time) along the path for the primary axis; thus, this implies that all axes will also undergo the same acceleration & deceleration. The movement of all selected axes occurs simultaneously.

It is recommended that the host decomposes long, slow, straight moves into multiple smaller segments so that an orderly Clear Command Block Queue request (e.g., for pausing a print) can take effect rapidly.

==== Set Active Toolhead (0x4)

This changes the active toolhead. This is primarily a hook for the firmware to take any firmware-specific actions on toolhead change and normally can be ignored by the client (but should still be sent by the host).

At power-on the system is assumed to be using toolhead 0.

.Command Block
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | Command Block Type Byte (== 0x04)
| 1 | new toolhead number
|=============================

The first byte of the Parameter will contain the new active toolhead number. The toolhead number must be a zero-indexed identifier which may have some significance to firmware-specific configuration (if used); otherwise, this command block is ignored by the client. The client is assumed to be using toolhead 0 initially.

==== Movement Checkpoint (0x5)

This comand block indicates the end of a sequence of moves - for instance at the end of job or when intentional pausing movement. The client will not activate the movement underrun prevention algorithms when a Movement Checkpoint command has been received after the last movement command.

NOTE: The final speed of the last movement command before the Movement Checkpoint must always be zero!

.Command Block
[width="50%",options="header", cols="30%,70%"]
|=============================
|Byte Number | Content
| 0 | Command Block Type Byte (== 0x05)
|=============================

== Event Reporting Extension

This extension allows a client to indicate events, debug, information & errors semi-asynchronously to the host.

The client maintains a queue of unacknowledged events. While unacknowledged events remain, the client sets bit 4 in the Control byte of all Reply frames generated. This indicates to the host that it can issue a Retrieve Event Order to retrieve and acknowledge these events.

Due to the fact that RAM space on the client is usually quite limited, the textual events are not sent as complete strings but rather as a format string id (e.g., the format id might correspond to "Error: Toolhead %hu temperature sensor exceeded maximum temperature %0.1f") and then only the two numeric arguments are sent in event.

=== Extension Orders

==== Retrieve Events (0x14)

The Retrieve Event Order includes a single Parameter byte which contains the last received event sequence number received by the host.

The events are identified by a rolling 8-bit sequence number. This is used by the host to acknowledge the receipt of events.

.Replies
- OK: The OK Reply includes the next block of unacknowledged events (which may be zero).

[width="50%",options="header", cols="30%,70%"]
|============================
| Length In Bytes | Content
| 1   | Sequence Number of first Event
| N   | Event 1
| M   | Event 2
| ..  |
| P   | Event 3
|============================

Each event is of the form:

[width="50%",options="header", cols="30%,70%"]
|============================
| Length In Bytes | Content
| 1   | Length (=N)
| 1   | Event Type
| 2   | Event Format Id
| N-3 | Event Arguments (optional)
|============================

Note: Events are only considered acknowledged when a Retrieve Event Order is received with a sequence number which is greater than or equal to the event number.

The Event Format Id is described by the Get Event Format Id Order.

===== Defined Event Types

[width="50%",options="header", cols="30%,70%"]
|============================
| Type | Meaning
| 0x00 | Error
| 0x01 | Debug
| 0x02 | Warning
| 0x03 | Information
| 0x80-0xfe | Experimental or unapproved event types
|============================

==== Get Number of Event Format Ids(0x15)

This order returns the number of entries in the Event Format Id table.

The Order Parameter contains no data.

.Replies
- OK: Parameter contains a 2 byte integer.

==== Get Event String Format Id (0x16)

The Order includes a 2 byte integer argument which is the request index into the string table (the first entry of the table uses Id value 0).

The Parameter returns the requested UTF8 format string which allows event argument information to be rendered as a human readable string. The format uses a subset of standard C printf format. The supported format types are d,i,u,x,X,f,F,e,E,g,s,c,%, the supported length specifiers for integers are hh, h, l & ll. Each argument is encoded in the Event Arguments field using the minimum number of bytes required to encode the type in big endian format (i.e., hh=1, h=2, l=4, ll= 8 bytes); ints or unsigned ints without a length specifier are assumed to be 4 bytes and all floating point numbers are also 4 bytes (as opposed to the normal 8 bytes). The %s string type should terminate when it reads a null character or the end of the argument data.

For instance, %-03u would correspond to a 4 byte argument; %-3hi corresponds to a 2 byte argument; %2.2f corresponds to an 4 byte argument. A format string of "Temperature sensor %hu exceeds maximum temperature (%d.%02hhuC)" would expect to read 7 bytes from the Event Arguments.

.Replies
- OK: Parameter contains the requested UTF8 format string.

=== Unsolicited client frames

==== New Event (0x51)

This optional unsolicited frame uses a Reply Code value of 0x51 to increase the responsiveness of the host to events.  The order indicates that a new event is available for collection using the Retrieve Events order and may optionally include a copy of the new event.

The frame has the following optional Parameter value content:

.Unsolicited Frame Parameter
[width="50%",options="header", cols="30%,70%"]
|============================
| Length In Bytes | Content
| 1   | Sequence Number of Event [optional]
| 1   | Event Type  [optional]
| 2   | Event Format Id [optional]
| N-3 | Event Arguments (optional)
|============================

NOTE: This does NOT replace normal event collection. The host must still acknowledge the received event and collect additional events using the Retrieve Events order.

The host may retransmit the New Event frame if it does not receive a valid Order frame within a reasonable period. An unsolicited New Event frame should not be generated by the client when a host order frame is currently being processed, that is, when a reply frame is pending.

== Future Extensions

The following is a list extensions which have been proposed but not currently included in the protocol (but may be included in future versions):

- a GPIO extension which gives analogue read and write access, as well as bidirectional pin access for system experimenters.
- a Servo motor extension
- a rotary encoder extension
- a pin-change event mechanism (so that changes in certain digital inputs do not need to be continuous polled by the host).
- an LCD extension

An SD card extension is not intended at this stage. Within the Pacemaker environment, the functionality traditionally provided by SD cards is better implemented using the Pacemaker Host platform instead.

== History

.document History
[width="90%",options="header"]
|=======================================
|Version| Date | Author| Comment
| 0.1   | 2013-06-17 | Lars PÃ¶tter and Robert Fairlie-Cuninghame.| first published draft
| 0.2   | 2013-07-25 | Lars PÃ¶tter and Robert Fairlie-Cuninghame.| changed CRC and Length
| 0.3   | 2013-08-18 | Lars PÃ¶tter and Robert Fairlie-Cuninghame.| added firmware config traversal, change length frame order
| 0.4   | 2013-10-01 | Lars PÃ¶tter and Robert Fairlie-Cuninghame.| changed frame order again, added unsolicited frames
|=======================================
